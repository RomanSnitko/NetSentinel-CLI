Этап 1: Проектирование интерфейса (MetricsEngine.hpp)

Для измерения скорости нам понадобится не только Boost.Asio, но и Boost.Beast (библиотека для работы с HTTP).

Что должно быть в заголовке:

    Конструктор, принимающий boost::asio::io_context& и std::shared_ptr<DatabaseManager>.

    Метод runAllTests() — точка входа, которая по очереди запускает тесты Latency и Speed.

    Приватные методы:

        measureLatency() — серия ICMP (или TCP) запросов для расчета пинга и джиттера.

        measureDownloadSpeed() — логика скачивания файла через Boost.Beast.

    Хранение результатов: переменные для накопления данных перед записью в БД.

Этап 2: Логика измерения Latency и Jitter (L3)

Это не просто один «пинг», а серия измерений для получения статистики.

Алгоритм:

    Серия запросов: Отправить 10 ICMP-пакетов (или выполнить 10 быстрых TCP-подключений к стабильному узлу, например 8.8.8.8).

    Замер времени: Для каждого запроса фиксировать время отправки и время получения ответа (RTT — Round Trip Time).

    Математика:

        Latency: Среднее арифметическое всех RTT.

        Jitter: Среднее отклонение между последовательными пингами (разница между пингом №2 и №1, №3 и №2 и т.д.).

    Результат: Сохранение промежуточных цифр в переменные класса.

Этап 3: Логика Speed Test через Boost.Beast (L7)

Здесь мы используем HTTP-клиент для загрузки данных.

Алгоритм:

    Подготовка: Выбрать надежный URL для теста (например, файл 10МБ с публичного сервера).

    Асинхронная цепочка Beast:

        Resolve: Превратить доменное имя в IP.

        Connect: Установить TCP-соединение.

        HTTP Request: Отправить GET запрос.

        HTTP Response: Начать чтение тела ответа.

    Расчет скорости:

        Зафиксировать время в момент получения первого байта данных (start_time).

        Считать общее количество полученных байт (total_bytes).

        Зафиксировать время окончания (end_time).

        Формула: (total_bytes * 8) / (duration_seconds * 1,000,000) = результат в Mbps.

Этап 4: Интеграция с Базой Данных

После завершения всех тестов данные должны быть консолидированы в одну запись.

Логика:

    Использовать таблицу metrics из твоего init.sql.

    Вызвать метод db_ptr->saveMetrics(latency, jitter, speed).

    Записать событие в network_events о том, что был проведен тест качества связи.

Этап 5: Реализация в src/MetricsEngine.cpp (Пошаговый план)

    Настройка Beast: Создать tcp::resolver и beast::tcp_stream.

    Цепочка callback-ов:

        on_resolve -> on_connect -> on_write (отправка GET).

        on_read (получение данных).

    Таймеры: Использовать steady_timer для контроля общей длительности теста (например, если скорость слишком низкая, прервать тест через 10 секунд).

    Обработка данных: Перевод байтов в мегабиты и расчет финальных метрик.

Этап 6: Подключение в main.cpp

В блоке -t или --test-speed:

    Инициализация: Создать boost::asio::io_context io_ctx;.

    Создание движка: auto metrics = std::make_shared<MetricsEngine>(io_ctx, db);.

    Запуск: Вызвать metrics->runAllTests();.

    Запуск цикла: io_ctx.run();. Программа будет «висеть», пока скачивается файл и замеряется пинг.

    Вывод: По завершении вывести красивые результаты в терминал (используя std::fixed и std::setprecision для точности до сотых).