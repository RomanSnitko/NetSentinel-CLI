Этап 1: Проектирование интерфейса (AuditEngine.hpp)

В отличие от DiscoveryEngine, здесь нам нужен io_context, так как асинхронные операции Boost.Asio привязываются к нему.

Что должно быть в заголовке:

    Конструктор, принимающий boost::asio::io_context& и std::shared_ptr<DatabaseManager>.

    Метод scanTarget(const std::string& ip, const std::vector<uint16_t>& ports) — точка входа.

    Приватный метод asyncCheckPort(const std::string& ip, uint16_t port) — внутренняя логика одного порта.

    Использование std::enable_shared_from_this (опционально, но профессионально), чтобы гарантировать, что объект AuditEngine не удалится, пока идут асинхронные проверки.

Этап 2: Логика проверки одного порта (The Core)

Это самая важная часть. Чтобы сканирование было быстрым, мы не должны ждать системный таймаут TCP (который может длиться 30 секунд). Нам нужно реализовать гонку двух асинхронных операций:

    Попытка подключения (socket.async_connect): Если порт открыт, это сработает быстро.

    Таймер (timer.async_wait): Мы ставим его, например, на 2 секунды.

Алгоритм внутри лямбда-выражений:

    Если подключение произошло первым: отменяем таймер, пишем в базу «Open», закрываем сокет.

    Если таймер сработал первым: принудительно закрываем сокет (это заставит async_connect завершиться с ошибкой «Operation aborted»), считаем порт закрытым.

Этап 3: Управление временем жизни (Async Lifetime)

В асинхронном коде С++ есть ловушка: сокет и таймер должны жить до тех пор, пока не завершится операция. Если они созданы как локальные переменные в функции, они исчезнут сразу после выхода из неё, и программа упадет.

Твой план действий:

    В методе asyncCheckPort создавай сокет и таймер через std::make_shared.

    Захватывай эти shared_ptr в лямбда-выражения ([socket, timer, ...]). Это увеличит счетчик ссылок, и объекты будут жить ровно столько, сколько нужно Boost.Asio.

Этап 4: Интеграция с Базой Данных

При успешном нахождении открытого порта нужно зафиксировать это.

    Используй db_ptr->logEvent(ip, "PORT_OPEN", "Port: " + std::to_string(port)).

    Также можно обновлять поле hostname в таблице devices, записывая туда список найденных портов.

Этап 5: Реализация в src/AuditEngine.cpp (Пошаговый план кода)

    Инициализация: Создать tcp::resolver для превращения строки IP в объект tcp::endpoint.

    Цикл запуска: Пробежаться по списку портов и для каждого вызвать asyncCheckPort.

    Внутри asyncCheckPort:

        Создать std::shared_ptr<tcp::socket>.

        Создать std::shared_ptr<boost::asio::steady_timer>.

        Запустить timer->async_wait(...).

        Запустить socket->async_connect(...).

Этап 6: Подключение в main.cpp

В блоке -a или --audit:

    Считать IP из argv[2].

    Подготовить список портов (например, 22, 80, 443, 3306, 5432, 8080).

    Создать boost::asio::io_context io_ctx;.

    Создать AuditEngine engine(io_ctx, db);.

    Вызвать engine.scanTarget(ip, ports);.

    Критический шаг: Вызвать io_ctx.run();. Именно этот вызов запустит все запланированные асинхронные проверки. Пока он работает, программа будет сканировать. Как только все порты ответят или выйдут по таймауту, run() завершится.